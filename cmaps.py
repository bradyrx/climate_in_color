#!/usr/bin/env python3
import os
import numpy as np
import glob as glob
import matplotlib.cm as mcm
import matplotlib.colors as mcolors
from matplotlib import rcParams
from PIL import Image
lut = rcParams['image.lut']

#------------------------------------------------------------------------------#
# Hardcoded bad maps
#------------------------------------------------------------------------------#
# MATLAB maps
matlab_data = {
    'jet':{
        'red': ((0., 0, 0), (0.35, 0, 0), (0.66, 1, 1), (0.89, 1, 1), (1, 0.5, 0.5)),
        'green': ((0., 0, 0), (0.125, 0, 0), (0.375, 1, 1), (0.64, 1, 1), (0.91, 0, 0), (1, 0, 0)),
        'blue':  ((0., 0.5, 0.5), (0.11, 1, 1), (0.34, 1, 1), (0.65, 0, 0), (1, 0, 0))
    },
    'hot':{
        'red': ((0., 0.0416, 0.0416), (0.365079, 1.000000, 1.000000), (1.0, 1.0, 1.0)),
        'green': ((0., 0., 0.), (0.365079, 0.000000, 0.000000), (0.746032, 1.000000, 1.000000), (1.0, 1.0, 1.0)),
        'blue':  ((0., 0., 0.), (0.746032, 0.000000, 0.000000), (1.0, 1.0, 1.0))
    },
    'hsv':{
        'red': ((0., 1., 1.),
                (0.158730, 1.000000, 1.000000),
                (0.174603, 0.968750, 0.968750),
                (0.333333, 0.031250, 0.031250),
                (0.349206, 0.000000, 0.000000),
                (0.666667, 0.000000, 0.000000),
                (0.682540, 0.031250, 0.031250),
                (0.841270, 0.968750, 0.968750),
                (0.857143, 1.000000, 1.000000),
                (1.0, 1.0, 1.0)),
        'green': ((0., 0., 0.),
                (0.158730, 0.937500, 0.937500),
                (0.174603, 1.000000, 1.000000),
                (0.507937, 1.000000, 1.000000),
                (0.666667, 0.062500, 0.062500),
                (0.682540, 0.000000, 0.000000),
                (1.0, 0., 0.)),
        'blue': ((0., 0., 0.),
                (0.333333, 0.000000, 0.000000),
                (0.349206, 0.062500, 0.062500),
                (0.507937, 1.000000, 1.000000),
                (0.841270, 1.000000, 1.000000),
                (0.857143, 0.937500, 0.937500),
                (1.0, 0.09375, 0.09375))
        }
    }

# GNU maps
_gnu_green = lambda x: x**3
_gnu_red   = lambda x: np.sqrt(x)
_gnu_blue  = lambda x: np.sin(x * 2 * np.pi)
_gnu2_red = lambda x: x / 0.32 - 0.78125
_gnu2_green = lambda x: 2 * x - 0.84
def _gnu2_blue(x):
    ret = np.zeros(len(x))
    m = (x < 0.25)
    ret[m] = 4 * x[m]
    m = (x >= 0.25) & (x < 0.92)
    ret[m] = -2 * x[m] + 1.84
    m = (x >= 0.92)
    ret[m] = x[m] / 0.08 - 11.5
    return ret

gnu_data = {
    'gnuplot':{
        'red':   _gnu_red,
        'green': _gnu_green,
        'blue':  _gnu_blue,
        },
    'gnuplot2':{
        'red':   _gnu2_red,
        'green': _gnu2_green,
        'blue':  _gnu2_blue,
        },
    'nipy_spectral':{
        'red': [(0.0, 0.0, 0.0), (0.05, 0.4667, 0.4667),
                (0.10, 0.5333, 0.5333), (0.15, 0.0, 0.0),
                (0.20, 0.0, 0.0), (0.25, 0.0, 0.0),
                (0.30, 0.0, 0.0), (0.35, 0.0, 0.0),
                (0.40, 0.0, 0.0), (0.45, 0.0, 0.0),
                (0.50, 0.0, 0.0), (0.55, 0.0, 0.0),
                (0.60, 0.0, 0.0), (0.65, 0.7333, 0.7333),
                (0.70, 0.9333, 0.9333), (0.75, 1.0, 1.0),
                (0.80, 1.0, 1.0), (0.85, 1.0, 1.0),
                (0.90, 0.8667, 0.8667), (0.95, 0.80, 0.80),
                (1.0, 0.80, 0.80)],
        'green': [(0.0, 0.0, 0.0), (0.05, 0.0, 0.0),
                (0.10, 0.0, 0.0), (0.15, 0.0, 0.0),
                (0.20, 0.0, 0.0), (0.25, 0.4667, 0.4667),
                (0.30, 0.6000, 0.6000), (0.35, 0.6667, 0.6667),
                (0.40, 0.6667, 0.6667), (0.45, 0.6000, 0.6000),
                (0.50, 0.7333, 0.7333), (0.55, 0.8667, 0.8667),
                (0.60, 1.0, 1.0), (0.65, 1.0, 1.0),
                (0.70, 0.9333, 0.9333), (0.75, 0.8000, 0.8000),
                (0.80, 0.6000, 0.6000), (0.85, 0.0, 0.0),
                (0.90, 0.0, 0.0), (0.95, 0.0, 0.0),
                (1.0, 0.80, 0.80)],
        'blue': [(0.0, 0.0, 0.0), (0.05, 0.5333, 0.5333),
                (0.10, 0.6000, 0.6000), (0.15, 0.6667, 0.6667),
                (0.20, 0.8667, 0.8667), (0.25, 0.8667, 0.8667),
                (0.30, 0.8667, 0.8667), (0.35, 0.6667, 0.6667),
                (0.40, 0.5333, 0.5333), (0.45, 0.0, 0.0),
                (0.5, 0.0, 0.0), (0.55, 0.0, 0.0),
                (0.60, 0.0, 0.0), (0.65, 0.0, 0.0),
                (0.70, 0.0, 0.0), (0.75, 0.0, 0.0),
                (0.80, 0.0, 0.0), (0.85, 0.0, 0.0),
                (0.90, 0.0, 0.0), (0.95, 0.0, 0.0),
                (1.0, 0.80, 0.80)],
        },
    }

# GIST package maps are by David H. Munro.
gist_data = {
    'gist_rainbow':(
        (0.000, (1.00, 0.00, 0.16)),
        (0.030, (1.00, 0.00, 0.00)),
        (0.215, (1.00, 1.00, 0.00)),
        (0.400, (0.00, 1.00, 0.00)),
        (0.586, (0.00, 1.00, 1.00)),
        (0.770, (0.00, 0.00, 1.00)),
        (0.954, (1.00, 0.00, 1.00)),
        (1.000, (1.00, 0.00, 0.75))
        ),
    'gist_ncar':{
        'red': ((0.0, 0.0, 0.0000),
                (0.3098, 0.0000, 0.0000),
                (0.3725, 0.3993, 0.3993),
                (0.4235, 0.5003, 0.5003),
                (0.5333, 1.0000, 1.0000),
                (0.7922, 1.0000, 1.0000),
                (0.8471, 0.6218, 0.6218),
                (0.8980, 0.9235, 0.9235),
                (1.0000, 0.9961, 0.9961)),
        'green': ((0.0, 0.0, 0.0000),
                (0.0510, 0.3722, 0.3722),
                (0.1059, 0.0000, 0.0000),
                (0.1569, 0.7202, 0.7202),
                (0.1608, 0.7537, 0.7537),
                (0.1647, 0.7752, 0.7752),
                (0.2157, 1.0000, 1.0000),
                (0.2588, 0.9804, 0.9804),
                (0.2706, 0.9804, 0.9804),
                (0.3176, 1.0000, 1.0000),
                (0.3686, 0.8081, 0.8081),
                (0.4275, 1.0000, 1.0000),
                (0.5216, 1.0000, 1.0000),
                (0.6314, 0.7292, 0.7292),
                (0.6863, 0.2796, 0.2796),
                (0.7451, 0.0000, 0.0000),
                (0.7922, 0.0000, 0.0000),
                (0.8431, 0.1753, 0.1753),
                (0.8980, 0.5000, 0.5000),
                (1.0000, 0.9725, 0.9725)),
        'blue': ((0.0, 0.5020, 0.5020),
                (0.0510, 0.0222, 0.0222),
                (0.1098, 1.0000, 1.0000),
                (0.2039, 1.0000, 1.0000),
                (0.2627, 0.6145, 0.6145),
                (0.3216, 0.0000, 0.0000),
                (0.4157, 0.0000, 0.0000),
                (0.4745, 0.2342, 0.2342),
                (0.5333, 0.0000, 0.0000),
                (0.5804, 0.0000, 0.0000),
                (0.6314, 0.0549, 0.0549),
                (0.6902, 0.0000, 0.0000),
                (0.7373, 0.0000, 0.0000),
                (0.7922, 0.9738, 0.9738),
                (0.8000, 1.0000, 1.0000),
                (0.8431, 1.0000, 1.0000),
                (0.8980, 0.9341, 0.9341),
                (1.0000, 0.9961, 0.9961)),
        },
    }

#------------------------------------------------------------------------------#
# Maps pulled from papers
#------------------------------------------------------------------------------#
def pull(file):
    # Load file
    img = Image.open(file)
    data = np.array(img)[...,:3]/255 # drop alpha channel and scale to 0-1
    long = np.argmax(data.shape) # N by M by 4, but which one is smaller?
    nshort = data.shape[1-long]
    vec = np.take(data, nshort//2, axis=1-long)
    # Get unique non-consecutive colors, so we can filter out divider colors
    # Why use lists of tuples? Because don't want axis-wise operations
    # on each channel, want to operate on unique data tuples.
    seen = {*()}
    tuples = [tuple(rgb) for rgb in vec]
    unique = []
    counts = []
    prev = None
    count = 1
    for rgb in tuples:
        if rgb!=prev:
            unique.append(rgb) # name of *current* rgb tuple
            counts.append(count) # number of appeariences for *previous* rgb tuple
            count = 1
        else:
            count += 1
        prev = rgb
    counts = [*counts[1:], count] # shift counts to match rgbs
    # Filter out dividers for colormap images with distinct levels and dividers
    # NOTE: We detect whether image has distinct levels by seeing if the distribution
    # of counts is bimodal! E.g. 1 pixel black, 20 pixels color, 1 pixel black, etc.
    med, mean = np.median(counts), np.mean(counts)
    if abs(mean - med)/med > 5:
        vec = [rgb for rgb,count in zip(unique,counts) if count >= np.mean(counts)]
    return vec

# Iterate through files
files = glob.glob(os.path.join(os.path.dirname(__file__), 'cmaps', 'cmap[0-9].png'))
paper_data = {os.path.splitext(os.path.basename(file))[0]:pull(file) for file in files}

#------------------------------------------------------------------------------#
# Generate colormaps
#------------------------------------------------------------------------------#
cmaps = []
for name,data in {**matlab_data, **gnu_data, **gist_data, **paper_data}.items():
    if isinstance(data, dict):
        cmap = mcolors.LinearSegmentedColormap(name, data, lut)
    else:
        cmap = mcolors.LinearSegmentedColormap.from_list(name, data, lut)
    mcm.cmap_d[name] = cmap
    cmaps.append(name)
